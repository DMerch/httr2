#' OAuth flow: authorization code
#'
#' @description
#' These functions implement the OAuth authorization code flow, as defined
#' by [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1),
#' Section 4.1. This is the most commonly used OAuth flow where the user is
#' opens a page in their browser, approves the access, and then returns to R.
#'
#' `oauth_flow_auth_code()` is a high-level wrapper that should
#' work with APIs that adhere relatively closely to the spec. The remaining
#' low-level functions can be used to assemble a custom flow for APIs that are
#' further from the spec:
#'
#' * `oauth_flow_auth_code_url()` generates the url where the user is sent.
#' * `oauth_flow_auth_code_listen()` starts an webserver that listens for
#'   the response from the resource server.
#' * `oauth_flow_auth_code_parse()` parses the query parameters returned from
#'   the server redirect, verifying that the `state` is correct, and returning
#'   the authorisation code.
#'
#' @family OAuth flows
#' @param app An [oauth_app()].
#' @param scope Scopes to be requested from the resource owner.
#' @param pkce Use "Proof Key for Code Exchange"? This adds an extra layer of
#'   security and should always be used if supported by the server.
#' @param auth_params Additional parameters passed to `oauth_flow_auth_code_url()`
#' @param token_params Additional parameters passed to `oauth_flow_access_token()`.
#' @param host_name Host name used to generate `redirect_uri`
#' @param host_ip IP address web server will be bound to.
#' @param port Port to bind web server to. By default, this uses a random port.
#'   You may need to set it to a fixed port if the API requires that the
#'   `redirect_uri` specified in the client exactly matches the `redirect_uri`
#'   generated by this function.
#' @export
oauth_flow_auth_code <- function(app,
                                 scope = NULL,
                                 pkce = TRUE,
                                 auth_params = list(),
                                 token_params = list(),
                                 host_name = "localhost",
                                 host_ip = "127.0.0.1",
                                 port = httpuv::randomPort()
) {
  oauth_flow_check_app(app,
    flow = "authorization code",
    is_confidential = TRUE,
    endpoints = c("token", "authorization"),
    interactive = TRUE
  )
  check_installed("httpuv")

  state <- nonce()
  redirect_url <- paste0("http://", host_name, ":", port)

  # TODO: implement PKCE

  # Redirect user to authorisation url, and listen for result
  user_url <- oauth_flow_auth_code_url(app,
    redirect_uri = redirect_url,
    scope = scope,
    state = state,
    auth_params = auth_params
  )
  utils::browseURL(user_url)
  result <- oauth_flow_auth_code_listen(host_ip, port)
  code <- oauth_flow_auth_code_parse(result, state)

  # Get access/refresh token from authorisation code
  # https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3
  oauth_flow_access_token(app,
    grant_type = "authorization_code",
    code = code,
    redirect_uri = redirect_url,
    !!!token_params
  )
}

# Authorisation request: make a url that the user navigates to
# https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1
#' @export
#' @rdname oauth_flow_auth_code
#' @param redirect_uri URL to which user should be redirected.
#' @param state Random state generated by `oauth_flow_auth_code()`. Used to
#'   verify that we're working with an authentication request that we created.
#'   (This is an unlikely threat for R packages since the webserver that
#'   listens for authorization responses is transient.)
oauth_flow_auth_code_url <- function(app,
                                     redirect_uri = NULL,
                                     scope = NULL,
                                     state = NULL,
                                     auth_params = list()) {
  url <- app_endpoint(app, "authorization")
  httr::modify_url(url, query = list2(
    response_type = "code",
    client_id = app$client$id,
    redirect_uri = redirect_uri,
    scope = scope,
    state = state,
    !!!auth_params
  ))
}

#' @export
#' @rdname oauth_flow_auth_code
oauth_flow_auth_code_listen <- function(host_ip = "127.0.0.1", port = 1410) {
  complete <- FALSE
  info <- NULL
  listen <- function(env) {
    if (!identical(env$PATH_INFO, "/")) {
      return(list(
        status = 404L,
        headers = list("Content-Type" = "text/plain"),
        body = "Not found"
      ))
    }

    query <- env$QUERY_STRING
    if (!is.character(query) || identical(query, "")) {
      complete <<- TRUE
    } else {
      complete <<- TRUE
      info <<- parse_form_urlencoded(query)
    }

    list(
      status = 200L,
      headers = list("Content-Type" = "text/plain"),
      body = "Authentication complete. Please close this page and return to R."
    )
  }
  server <- httpuv::startServer(host_ip, port, list(call = listen))
  withr::defer(httpuv::stopServer(server))

  # TODO: make this a progress bar
  inform("Waiting for authentication in browser...")
  inform("Press Esc/Ctrl + C to abort")
  while (!complete) {
    httpuv::service()
  }
  httpuv::service() # send data back to client

  if (is.null(info)) {
    abort("Authentication failed; invalid url from server.")
  }

  info
}

# application/x-www-form-urlencoded defined in
# https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1
# Spaces are first replaced by +
parse_form_urlencoded <- function(query) {
  query <- gsub("^\\?", "", query)
  query <- httr:::parse_query(query)
  query[] <- gsub("+", " ", query, fixed = TRUE)
  query
}

# Authorisation response: get query params back from redirect
# https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2
#' @export
#' @rdname oauth_flow_auth_code
#' @param query List of query parameters returned by `oauth_flow_auth_code_listen()`.
oauth_flow_auth_code_parse <- function(query, state) {
  if (has_name(query, "error")) {
    # https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1
    # Never see problems with redirect_uri
    oauth_flow_abort(query$error, query$error_description, query$error_uri)
  }

  if (query$state != state) {
    abort("Authentication failure: state does not match")
  }

  query$code
}

---
title: "oauth"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(httr2)
```

## RFC6749: OAuth 2.0

Allows third party to authenticate on behalf or on its own behalf.

Instead of sharing your username and password with a third party, you instead give the 3rd party permission to perform actions on your behalf.

resource owner = user; user-agent = browser;

Basic flow:

-   Client makes authorisation request to resource owner, and it returns an authorisation grant (four types are defined in this rfc: authorisation code, implicit, resource owner password credentials, and client credentials).

-   Client makes authorisation grant to authorisation server (which can be different to resource server, even though that appears to be rare in practice) which returns access token.
    Can also provides a refresh token which is a way to get new access tokens (which either have limited lifetime or limited scope; this reduces impact of MITM attacks).

-   Client uses access token to access protected resources.

### Client setup

Resource server provides some way to register a new client.

**Confidential** client can keep secrets from resource owner; **public** clients can not.

Client profiles:

-   web app: can manage secrets only accessible to client authors

-   user-agent-based (i.e in browser): all credentials accessible to resource owner; can easily use browser auth

-   native: public client installed on device used by resource owner.
    generally possible to extract secrets with some effort.

Each client is identified by a (non secret) client id.

For client to authenticate to authorisation sever:

-   Can use HTTP basic auth with client ID as user name and client secret as password.

-   Can also (but not recommended) include in form encoded request body

-   Also free to use own setup.

## RC6750: Bearer Token Usage

<https://datatracker.ietf.org/doc/html/rfc6750>

Defines how to use a bearer token.
(A bearer token is an opaque string that is meaningful to the server.)

Three options in order of preference:

-   In header: `Authorization: Bearer mF_9.B5f-4.1JqM`

-   Form encoded in body.
    Can't use for GET.
    Can include other parameters.

         POST /resource HTTP/1.1
         Host: server.example.com
         Content-Type: application/x-www-form-urlencodedsla

         access_token=mF_9.B5f-4.1JqM

-   In query parameter:

        GET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1
        Host: server.example.com

    Request should also include `Cache-Control: no-store`.
    Least favoured because easy to leak in logs, history, etc.

If client doesn't provide one these, server **must** include `WWW-authenticate` header.
Can include attributes:

-   realm (may) from RFC2617

-   scope (may): "space-delimited list of case-sensitive scopes" indicating required scopes.

-   error (should), error_description (may), error_uri (may): error code + optional description and link to learn more.
    Error code is one of invalid_request (400), invalid_token (401), insufficient_scope (403)

<!-- -->

     HTTP/1.1 401 Unauthorized
     WWW-Authenticate: 
       Bearer realm="example",
       error="invalid_token",
       error_description="The access token expired"

## Grant types/flows

### Authorisation code with PKCE (native app) (RFC8252)

<https://datatracker.ietf.org/doc/html/rfc8252>; `grant_type: authorization_code` + public client, since no true way for a native (desktop or mobile) to keep a secret.

Should use PKCE ([\<https://datatracker.ietf.org/doc/html/rfc7636\>](https://datatracker.ietf.org/doc/html/rfc7636){.uri})

Examples: [Google](https://developers.google.com/identity/protocols/oauth2/native-app) (but requires client_secret in when getting access/refresh token).

### Authorisation code (web app) (RFC6749)

<https://datatracker.ietf.org/doc/html/rfc6749#section-4.1>; `grant_type: authorization_code`.

Standard flow where user logs into resource server, then client gets code via redirect.
Browser (user-agent) never sees token.
Not perfectly suited for an R package, but it's the only form supported by many APIs so we do the best we can.

Examples: [Google](https://developers.google.com/identity/protocols/oauth2/web-server), [Azure](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow), [GitHub](https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow),

### Device (RFC8628)

<https://datatracker.ietf.org/doc/html/rfc8628>; `grant_type: urn:ietf:params:oauth:grant-type:device_code`

Examples: [Google](https://developers.google.com/identity/protocols/oauth2/limited-input-device), [Github](https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#device-flow).

### Implicit (RFC6749)

<https://datatracker.ietf.org/doc/html/rfc6749#section-4.2>

Skip authorisation code, and get access token directly.
Authorisation server does not authenticate client (??).
No refresh tokens.
Useful if you really don't want to store client secret.

Now mostly deprecated:<https://developer.okta.com/blog/2019/05/01/is-the-oauth-implicit-flow-dead>

Difficult to get with non-native web apps because it returns the auth information in the url fragment which is never sent to the server (although we could of course hack around that with some js).
But together with the previous point suggests that it's not appropriate to implement in httr2.

Examples: [Google](https://developers.google.com/identity/protocols/oauth2/javascript-implicit-flow).

### Refresh token (6749)

<https://datatracker.ietf.org/doc/html/rfc6749#section-6>; `grant_type: refresh_token`

Refresh token is bound to client; if client is confidential must authenticate.

### Token exchange (RFC8693)

[\<https://datatracker.ietf.org/doc/html/rfc8693\>](https://datatracker.ietf.org/doc/html/rfc8693){.uri}

### JWT (RFC7523)

Examples: [Google](https://developers.google.com/identity/protocols/oauth2/service-account#httprest).

### Client credentials (RFC6749)

Used when client is acting on its own behalf.

### Resource owner password (RFC6749)

Use username & password once to get an access (so client doesn't need to store them.

## Extensibility

Every API seems to differ a little bit - the major flow is all the same but there are additional query parameters you might want to pass along, the auth is slightly different, and there might be additional content that you want to expose to the user.
How do we expose this to the user?

1.  Export the individual functions that power each flow - if your API varies from the spec, you can provide a complete function.

    **Pros**: total flexibility

    **Cons**: have to export a lot of functions; user has to do a lot of work (and this is not trivial code)

2.  Provide S3 methods

3.  Provide individual arguments - this would match the API elsewhere in httr2, but I don't think it can work here; there are just too many places where variation might occur.

4.  Bundle together functions into a list.

5.  Bundle together functions into a R6 object.
    Would make it easier to flow state across pieces

Current thinking - provide obvious extension points, and export components so that you can reuse if needed.

